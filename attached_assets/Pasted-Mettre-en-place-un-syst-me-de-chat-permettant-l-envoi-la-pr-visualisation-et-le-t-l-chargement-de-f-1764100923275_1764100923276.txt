Mettre en place un systÃ¨me de chat permettant lâ€™envoi, la prÃ©visualisation et le tÃ©lÃ©chargement de fichiers PDF, avec un frontend sur Vercel, un backend sur Render, et une base PostgreSQL. Le stockage de fichiers doit Ãªtre externalisÃ© (S3 ou Ã©quivalent) avec presigned URLs.

ğŸ”§ 1. Exigences fondamentales

Lâ€™IA doit respecter :

1.1 â€” Aucune donnÃ©e binaire ne doit transiter par Vercel

Le frontend ne doit jamais transfÃ©rer un fichier PDF via un endpoint dâ€™API hÃ©bergÃ© sur Vercel.

Tous les uploads doivent aller directement vers le storage cloud, via des URLs signÃ©es gÃ©nÃ©rÃ©es par le backend.

1.2 â€” Render ne doit pas stocker de fichiers

Render dispose dâ€™un filesystem temporaire.

Le backend doit uniquement gÃ©nÃ©rer des presigned URLs.

Les fichiers doivent Ãªtre stockÃ©s dans S3/Spaces/Supabase Storage.

1.3 â€” Les URLs retournÃ©es au frontend doivent toujours Ãªtre temporaires

Upload â†’ presigned URL PUT

Download / preview â†’ presigned URL GET

ğŸ— 2. Architecture recommandÃ©e

DÃ©composer en 4 modules bien sÃ©parÃ©s :

Module A â€” Frontend (Vercel)

Fonctions requises :

Composant dâ€™upload â†’ appelle /upload/request

Upload direct vers S3 via PUT

Demande dâ€™URL signÃ©e de lecture â†’ /file/{id}/presign

Affichage PDF natif via <embed> ou React-PDF

Aucune logique de sÃ©curitÃ©.

Module B â€” Backend (Render)

ResponsabilitÃ©s :

Authentification (JWT, cookie)

DÃ©finition du stockage (S3 SDK)

CrÃ©ation des tables dans PostgreSQL

GÃ©nÃ©ration des presigned URLs

Emission dâ€™Ã©vÃ©nements WebSocket pour les nouveaux messages

Module C â€” Storage externe

Exemples :

AWS S3

DigitalOcean Spaces

Supabase Storage

Cloudflare R2

Vercel Blob (si souhaitÃ©)

Configuration minimale :

bucket privÃ©

policy permettant lâ€™usage de presigned URLs

Module D â€” Base PostgreSQL (Render)

Tables essentielles :

files

messages

users

channels

ğŸ“ 3. Logique obligatoire pour lâ€™upload
3.1 â€” Ã‰tape 1 : Le frontend demande une URL PUT

POST /upload/request
DonnÃ©es :

filename

mime

size

3.2 â€” Le backend :

vÃ©rifie lâ€™authentification

gÃ©nÃ¨re un UUID de fichier

prÃ©pare un storage path propre

gÃ©nÃ¨re une presigned PUT URL valable 5 minutes

crÃ©e un record dans la table files (status = â€œpendingâ€)

renvoie :

{
  "fileId": "...",
  "uploadUrl": "..."
}

3.3 â€” Ã‰tape 2 : Le frontend upload le PDF

Envoi direct via :

PUT <uploadUrl>
Content-Type: application/pdf
Body: <binary>

3.4 â€” Ã‰tape 3 : Le frontend confirme lâ€™upload

POST /upload/confirm
DonnÃ©es : { fileId }

Le backend passe :

files.status = "uploaded"

ğŸ“„ 4. Logique obligatoire pour la prÃ©visualisation
4.1 â€” Le frontend reÃ§oit un message avec un fileId
4.2 â€” Le frontend demande une URL GET

GET /file/{fileId}/presign

4.3 â€” Le backend :

vÃ©rifie que lâ€™utilisateur a accÃ¨s au salon/message

gÃ©nÃ¨re une presigned URL GET

durÃ©e 10 minutes

renvoie :

{
  "url": "..."
}

4.4 â€” Le frontend affiche le PDF

Utiliser :

<embed src={url} type="application/pdf" />


ou
React-PDF si rendu prÃ©cis requis.

ğŸ” 5. SÃ©curitÃ© impÃ©rative

Lâ€™IA doit impÃ©rativement implÃ©menter :

Bucket privÃ© (aucun fichier accessible publiquement)

Toutes les URLs doivent Ãªtre presigned

Toutes les URLs doivent Ãªtre temporaires

Les presigned URLs PUT ne doivent autoriser que le type MIME demandÃ©

Le backend doit valider que le fileId appartient Ã  lâ€™utilisateur/salon avant de gÃ©nÃ©rer une URL GET

ğŸ§ª 6. Tests indispensables

Avant de dÃ©ployer, tester :

6.1 â€” upload complet

Frontend â†’ request â†’ presigned PUT â†’ upload â†’ confirm â†’ message crÃ©Ã©

6.2 â€” prÃ©visualisation

Un utilisateur autorisÃ© obtient lâ€™URL GET

Un utilisateur non autorisÃ© doit Ãªtre refusÃ©

6.3 â€” expiration des URLs

Les URLs signÃ©es doivent devenir invalides aprÃ¨s expiration.

ğŸš€ 7. Recommandations pour une IA exÃ©cutante (comme Replit)

Voici la version la plus â€œmachine-friendlyâ€ :

ğŸ”Š Instructions Ã  suivre Ã  la lettre :

Ne jamais transfÃ©rer de fichiers via Render ou Vercel.

Toujours stocker les PDF dans un bucket privÃ©.

Toujours utiliser des presigned URLs PUT (upload) et GET (preview/download).

Toujours enregistrer les fichiers dans PostgreSQL avant la gÃ©nÃ©ration dâ€™URL.

Toujours vÃ©rifier les permissions avant de gÃ©nÃ©rer une presigned GET URL.

Toujours renvoyer des URLs temporaires (5min PUT, 10min GET).

Le frontend doit :

dâ€™abord demander la presigned PUT

ensuite uploader directement

ensuite confirmer au backend

ensuite envoyer un message contenant fileId

Le backend doit :

gÃ©rer lâ€™auth

gÃ©nÃ©rer presigned URL

gÃ©rer la DB

Ã©mettre lâ€™Ã©vÃ©nement message

Le frontend doit afficher le PDF via un <embed> ou React-PDF.

Aucune URL publique permanente ne doit Ãªtre crÃ©Ã©e.

ğŸ¯ Courte phrase rÃ©capitulative (parfaite pour une IA) :

â€œStockage = presigned URLs. Backend = auth + permissions + DB. Frontend = orchestration + preview. Aucun fichier ne passe par Render/Vercel.â€